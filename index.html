<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>Tetris Totally Normal Edition</title>

    <meta name="description" content="Totally normal tetris featuring all the very normal pieces.">

    <meta property="og:site_name" content="bleach.dev">
    <meta property="og:title" content="Tetris Totally Normal Edition">
    <meta property="og:url" content="https://tetris.bleach.dev/">
    <meta property="og:image" content="https://tetris.bleach.dev/static/tetris.png">
    <meta property="og:type" content="website">
    <meta property="og:description" content="Totally normal tetris featuring all the very normal pieces.">
    <meta name="theme-color" content="#ebafcc">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" type="image/x-icon" href="static/tetris.ico">
    <link rel="stylesheet" href="https://bleach.dev/static/css/main.css">
    <link rel="stylesheet" href="tetris.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
    <script src="https://ms.bleach.dev/words.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
</head>
<body>

<div id="game">
    <div id="sp-container">
        <div class="small-grid">
            <h2 style="margin: 0;">HOLD</h2>
            <div id="holding" class="grid">
                <div class="grid-cell"></div>
            </div>
        </div>

        <div id="tetris" class="grid"></div>

        <div class="small-grid">
            <h2 style="margin: 0;">NEXT</h2>
            <div id="next-1" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-2" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-3" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-4" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-5" class="grid">
                <div class="grid-cell"></div>
            </div>
        </div>
    </div>

    <div id="vs-container">
        <div id="vs-tetris" class="grid"></div>

        <div class="small-grid">
            <h2 style="margin: 0;">NEXT</h2>
            <div id="next-6" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-7" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-8" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-9" class="grid">
                <div class="grid-cell"></div>
            </div>
            <div id="next-10" class="grid">
                <div class="grid-cell"></div>
            </div>
        </div>
    </div>

    <div id="sp-text-container">
        <div id="progress">
            <div id="progressbar"></div>
            <p id="cleared-text">Lines Cleared: 0</p>
        </div>
    </div>
    <div id="vs-text-container">
        <div style="display: inline-block; margin-right: 120px; width: 350px;">
            <span id="vs-player-1" style="font-size: 20px;">...</span>
        </div>
        <div style="display: inline-block; margin-left: 120px; width: 350px;">
            <span id="vs-player-2" style="font-size: 20px;">...</span>
        </div>
    </div>

    <p id="timer">00:00.00</p>
</div>

<div class="bottom-right">
    <p class="corner-text">
        v1.2.1<br>
        A&nbsp;<a href="https://bleach.dev" class="bleach-link">bleach.dev</a>&nbsp;Game
    </p>
</div>
<div class="bottom-left">
    <p class="corner-text">
        Controls:<br>
        <b>ARROWS</b> Move<br>
        <b>X/Z/UP</b> Rotate<br>
        <b>SPACE</b> Drop Piece<br>
        <b>C/SHIFT</b> Hold Piece
    </p>
</div>

<div class="toast" id="menu-toast" style="display: flex;">
    <div class="box">
        <h1>Tetrisâ„¢<br>Totally Normal Edition</h1>

        <button class="menu-button" onclick="openToast('play-toast');">Singleplayer</button>
        <br/>
        <button class="menu-button" onclick="hostGame(getAndSaveUsername('username'));">Versus <span style="font-size: 14px;">(betaâ„¢)</span></button>
        <br/>
        <button class="menu-button" style="font-size: 16px;" onclick="openToast('leaderboard-toast', false);">Leaderboard</button>
        <div class="hr"></div>

        <label for="username">Username</label>
        <input type="text" id="username" name="username-join">
    </div>
</div>

<div class="toast" id="play-toast">
    <div class="box">
        <h1>Singleplayer</h1>
        <p class="toast-header">Goal: Clear 40 Lines.</p>
        <p id="play-text">You can continue playing after 40 lines<br/>to get a higher "Most Lines" score!</p>
        <button class="menu-button" id="play-button" onclick="start();">Play</button>
        <button class="half-menu-button" onclick="openToast('menu-toast');">Back to Menu</button>
        <button class="half-menu-button" onclick="openToast('leaderboard-toast', false);">Leaderboard</button>
    </div>
</div>

<div class="toast" id="vs-toast">
    <div class="box">
        <h1>1v1 Versus</h1>
        <button id="vs-copy">ðŸ“‹</button>
        <span class="toast-header" id="vs-code">code brokey :(</span>
        <p>Share the url above to start<br/>Waiting for player to join...</p>
        <button class="half-menu-button" onclick="clearVs(); openToast('menu-toast');">Back to Menu</button>
        <button class="half-menu-button" onclick="openToast('leaderboard-toast', false);">Leaderboard</button>
    </div>
</div>

<div class="toast" id="vs-join-toast">
    <div class="box">
        <h1>1v1 Versus</h1>
        <p class="toast-header" id="vs-join-text" style="margin: 20px 20px 0;">Loading...</p>
        <p class="toast-header" id="vs-join-text-2" style="margin: 5px 20px 20px;"></p>
        <div id="vs-username-container">
            <div class="hr"></div>
            <label for="vs-username">Username</label>
            <input type="text" id="vs-username" name="username-join">
        </div>
        <button class="menu-button" id="vs-join-button" disabled="disabled">Join</button>
        <button class="half-menu-button" onclick="clearVs(); openToast('menu-toast');">Back to Menu</button>
        <button class="half-menu-button" onclick="openToast('leaderboard-toast', false);">Leaderboard</button>
    </div>
</div>

<div class="toast" id="leaderboard-toast">
    <div class="box">
        <h1>Leaderboard</h1>
        <div>
            <button style="margin: 0" onclick="closeToast('leaderboard-toast');"><</button>
            <button class="leaderboard-button" id="lb-lines" style="text-decoration: underline;"
                    onclick="fetchLeaderboard(`https://api.bleach.dev/tetris/leaderboardlines`);
                        document.getElementById(`lb-lines`).style.textDecoration = `underline`;
                        document.getElementById(`lb-time`).style.textDecoration = ``;">Most Lines</button>
            <button class="leaderboard-button" id="lb-time"
                    onclick="fetchLeaderboard(`https://api.bleach.dev/tetris/leaderboardtime`);
                        document.getElementById(`lb-time`).style.textDecoration = `underline`;
                        document.getElementById(`lb-lines`).style.textDecoration = ``;">40 Lines</button>
            <div class="box" id="leaderboard">
                <div>Loading..</div>
            </div>
        </div>
    </div>
</div>


<script>
    class Piece {
        constructor(array, width) {
            this.array = array;
            this.width = width;
            this.height = array.length / width;
        }
    }

    // Yes, I'm aware these are in fact not toasts, please send further complaints to thisisnotatoast@bleach.dev
    const TOASTS = [ "menu-toast", "play-toast", "vs-toast", "vs-join-toast", "leaderboard-toast"].map(t => document.getElementById(t));
    const USERNAMES = [ "username", "vs-username" ];
    const SYNTH = new Tone.FMSynth().toDestination();

    const DEFAULT_COLORS = ["#3bb88a", "#6f5fc0", "#c06f3e", "#c5ad44", "#bb3e44", "#af4ba6", "#86b43a"];
    const PIECES = [
        new Piece([1, 1, 1, 1], 4), // I
        new Piece([1, 0, 0, 1, 1, 1], 3), // J
        new Piece([0, 0, 1, 1, 1, 1], 3), // L
        new Piece([1, 1, 1, 1], 2), // O
        new Piece([1, 1, 0, 0, 1, 1], 3), // S
        new Piece([0, 1, 0, 1, 1, 1], 3), // T
        new Piece([0, 1, 1, 1, 1, 0], 3), // Z
        new Piece([1], 1), // .
        new Piece([1, 1], 2), // I-2
        new Piece([1, 1, 1, 0], 2), // L-
        new Piece([1, 1, 1], 3), // I-3
        new Piece([1, 1, 1, 1, 0, 0, 1, 0, 0], 3), // L+
        new Piece([0, 1, 0, 0, 1, 0, 1, 1, 1], 3), // T+
        new Piece([1, 1, 1, 1, 0, 1, 0, 0], 4), // T-4
        new Piece([1, 1, 1, 1, 0, 0, 1, 0], 4), // T-4A
        new Piece([1, 1, 1, 1, 1, 1, 1, 1, 1], 3), // O-3
        new Piece([0, 1, 1, 0, 1, 0, 1, 1, 0], 3), // S+
        new Piece([1, 1, 0, 0, 1, 0, 0, 1, 1], 3), // Z+
        new Piece([1, 0, 1, 0], 2), // DIAGONAL-2
        new Piece([1, 1, 1, 1, 1], 5), // I-5
        new Piece([1, 0, 1, 0, 1, 0], 3), // V
        new Piece([0, 1, 1, 1, 1, 0, 1, 0, 0], 3), // W
        new Piece([0, 1, 1, 1, 1, 1, 0, 0], 4), // LONG S
        new Piece([1, 1, 1, 0, 0, 0, 1, 1], 4), // LONG Z
        new Piece([0, 0, 1, 0, 1, 0, 0, 1, 0], 3), // I-2+DIAGONAL
        new Piece([0, 1, 1, 0, 1, 1, 1, 1], 4), // 4x2 MINUS CORNERS
        new Piece([1, 1, 0, 0, 1, 1, 0, 1, 0], 3), // F
        new Piece([0, 1, 0, 1, 1, 1, 0, 1, 0], 3), // +
        new Piece([0, 0, 1, 0, 1, 0, 1, 0, 0], 3), // DIAGONAL-3
        new Piece([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 4), // O-4
        new Piece([1, 0, 1, 1, 1, 1], 3), // U
        new Piece([1, 0, 0, 1], 4), // EYES
        new Piece([0, 1, 0, 1, 1, 0, 0, 0, 1], 3), // Y
        new Piece([1, 0, 1, 1, 0, 0], 3), // I-2+EYES
        new Piece([1, 1, 0, 1, 1, 0, 0, 1, 0, 0], 5), // LONG V
        new Piece([0, 1, 0, 0, 0, 0, 1, 0, 1], 3), // 3 CORNERS
        new Piece([1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0], 4), // L++
        new Piece([0, 0, 1, 0, 0, 0, 1, 0, 0], 3), // DIAGONAL EYES
        new Piece([1, 0, 1, 0, 0, 0, 1, 0, 1], 3), // CORNERS
    ];
    for (let i = 0; i < PIECES.length; i++) {
        for (let k = 0; k < PIECES[i].array.length; k++) {
            const v = PIECES[i].array[k];
            PIECES[i].array[k] = v === 0 ? 0 : i < DEFAULT_COLORS.length ? DEFAULT_COLORS[i] : `hsla(${i * 0.17 * 360}, 100%, 70%, 1)`;
        }
    }
    const BUH_PIECES = [
        new Piece([0, 1, 0, 1, 1, 1], 3), // T
        new Piece([1, 0, 1, 0, 1, 0], 3), // V
        new Piece([1, 1, 1, 1, 0, 0, 1, 0, 0], 3), // L+
        new Piece([0, 1, 0, 0, 1, 0, 1, 1, 1], 3), // T+
        new Piece([1, 1, 1, 1, 1, 1, 1, 1, 1], 3), // O-3
        new Piece([0, 1, 1, 0, 1, 0, 1, 1, 0], 3), // S+
        new Piece([1, 1, 0, 0, 1, 0, 0, 1, 1], 3), // Z+
        new Piece([1, 1, 0, 0, 1, 1, 0, 1, 0], 3), // F
        new Piece([0, 1, 0, 1, 1, 1, 0, 1, 0], 3), // +
        new Piece([0, 0, 1, 0, 1, 0, 1, 0, 0], 3), // DIAGONAL-3
        new Piece([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 4), // O-4
        new Piece([1, 0, 1, 1, 1, 0, 1, 0, 0], 3), // ??
        new Piece([1, 0, 1, 1, 0, 1, 0, 1, 0], 3), // TALL V
        new Piece([1, 0, 1, 1, 1, 0, 0, 1, 1], 3), // W WITH DOT
        new Piece([1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], 5), // V+
        new Piece([0, 1, 0, 0, 0, 0, 1, 0, 1], 3), // 3 CORNERS
        new Piece([0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], 4), // S++
        new Piece([0, 1, 0, 1, 0, 1, 0, 1, 0], 3), // DIAMOND
        new Piece([0, 0, 1, 0, 0, 0, 1, 0, 0], 3), // DIAGONAL EYES
        new Piece([1, 1, 1, 1, 0, 1, 1, 1, 1], 3), // DONUT
        new Piece([1, 1, 1, 1, 1, 1, 1], 1), // I-7
        new Piece([1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], 5), // ROTATED I-5
        new Piece(Array(25).fill(1), 5), // O-5
        new Piece([1, 0, 1, 0, 0, 0, 1, 0, 1], 3), // CORNERS
        new Piece(Array(36).fill(1), 6), // O-6
        new Piece(Array(49).fill(1), 7), // O-7
    ];
    for (let i = 0; i < BUH_PIECES.length; i++) {
        for (let k = 0; k < BUH_PIECES[i].array.length; k++) {
            BUH_PIECES[i].array[k] = BUH_PIECES[i].array[k] === 0 ? 0 : "#cccccc";
        }
    }

    const height = 22;
    const width = 10;
    const boards = [ new Array(height * width).fill(0) ];
    const fallingBoards = [ new Array(height * width).fill(0) ];
    const nextPieces = []; // Each board has a pair of 5 pieces

    let canHold = true;
    let holdingPiece;
    let clearedLines = 0;
    let gracePeriod = 0;
    let buh = 0; // How much buh garbage you have
    let tempBuh = 0;

    let timer = 0;
    let lastTime;

    let gameId;
    let moves;

    // 0 >< Board update [0, board[], fallingBoard[], Piece[next1], Piece[next2]..]
    // 1 >< Send over buh [1, amount]
    // 252 < Send Line 2 Message [252, "message"]
    // 253 < Open Rematches [253]
    //     > Request Rematch [253]
    //     < Start Rematch [253, 1]
    // 254 > End Game [254, "messageKey"]
    //     < Show message [254, "message", losingPlayer]
    // 255 > Request Game Info [255]
    //     > Join Game [255, "username"]
    //     < Game Info [255, yourIndex, "player1", "player2"..]
    let serverCon;
    let clients = [];
    let vsPlayers = [];
    let yourIndex;
    let rematches = [];

    const keyStates = {};
    // Always process keyups so keys don't get glued down when we stop ticking
    document.addEventListener("keyup", e => keyStates[e.key] = null);
    const handleKeyDown = e => {
        if (!Object.hasOwn(keyStates, e.key) || keyStates[e.key] === null)
            keyStates[e.key] = 0;

        if (e.key === "ArrowUp" || e.key.toLowerCase() === "x" || e.key.toLowerCase() === "z") {
            rotateFalling(e.key === "z");
            if (gracePeriod >= 0)
                gracePeriod = 1;

            SYNTH.triggerAttackRelease("G4", "256n", Tone.now(), 0.3);
        } else if (e.key === " ") {
            while (offsetFalling(0, 1, 0)) {}
            gracePeriod = 0;
            tick();

            SYNTH.triggerAttackRelease("D3", "24n", Tone.now(), 0.2);
        } else if (e.key === "Shift" || e.key.toLowerCase() === "c") {
            holdPiece();
        } else if (e.key === "Escape" && !serverCon) {
            document.getElementById("play-text").innerHTML = `The game is paused.`;
            document.getElementById("play-button").innerText = "Continue";
            document.getElementById("play-button").onclick = resume;
            stop();
        }
    };

    let ticker = 0;
    let lastTick = 0;
    let tickId;
    const tickInterval = () => {
        const diff = Math.floor(performance.now() - ticker);
        lastTick = ticker;
        ticker += diff;

        const leftDown = keyStates["ArrowLeft"] === 0 || (keyStates["ArrowLeft"] >= 200 && keyStates["ArrowLeft"] % 60 < (keyStates["ArrowLeft"] - diff) % 60);
        const rightDown = keyStates["ArrowRight"] === 0 || (keyStates["ArrowRight"] >= 200 && keyStates["ArrowRight"] % 60 < (keyStates["ArrowRight"] - diff) % 60);
        const downDown = keyStates["ArrowDown"] === 0 || (keyStates["ArrowDown"] >= 200 && keyStates["ArrowDown"] % 60 < (keyStates["ArrowDown"] - diff) % 60);
        if (leftDown || rightDown || downDown) {
            if (gracePeriod >= 0)
                gracePeriod = 1;

            if ((((leftDown || rightDown) && offsetFalling(leftDown ? -1 : 1, 0, 0))) || (downDown && offsetFalling(0, 1, 0))) {
                render();
                SYNTH.triggerAttackRelease(leftDown || rightDown ? "E#4" : "C#4", "256n", Tone.now(), 0.4);
            }
        }

        for (let key in keyStates) {
            if (keyStates[key] !== null) {
                keyStates[key] += diff;
            }
        }

        const tickRate = Math.max(65, 450 - (buh * 7));
        if (ticker % tickRate < lastTick % tickRate) {
            tick();
        }

        timer = Math.round(timer + (performance.now() - lastTime));
        lastTime = performance.now();
        document.getElementById("timer").innerText = formatTime(timer);
    };

    // Init
    document.addEventListener("keydown", e => {
        if (e.key === "Escape") {
            closeToast("leaderboard-toast");
        }

        if (e.key === "Enter" && document.getElementById("play-toast").style.display === "flex") {
            document.getElementById("play-button").click();
        }
    });

    // Set username
    USERNAMES.forEach(u => document.getElementById(u).value =
        document.cookie.split("; ").find(row => row.startsWith("username="))?.split("=")[1]
        ?? words[~~(Math.random() * (words.length - 1))] + (Math.random() > 0.5 ? ~~(Math.random() * 100) : ""));

    // Setup Tetris Grid
    for (const element of [ initGrid("tetris", width, height), initGrid("vs-tetris", width, height) ]) {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add(y <= 1 ? "grid-cell-hidden" : 'grid-cell');
                cellElement.id = element.id + "-" + x + "-" + y;
                element.appendChild(cellElement);
            }
        }
    }

    fetchLeaderboard("https://api.bleach.dev/tetris/leaderboardlines");

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("join")) {
        const code = urlParams.get("join");
        openToast("vs-join-toast");

        const metadataPeer = new peerjs.Peer();
        metadataPeer.on('open', id => {
            console.log('Client peer ID is: ' + id);

            const metadataCon = metadataPeer.connect("bl-ttne-" + code);
            metadataCon.on('open', () => {
                metadataCon.on('data', data => {
                    document.getElementById("vs-join-text").innerHTML = `<b>${data[2]}</b> invited you to tetris gaming!`;
                    document.getElementById("vs-join-text-2").innerHTML = "Click Join to start";
                    document.getElementById("vs-join-button").disabled = "";
                    document.getElementById("vs-join-button").onclick = () => {
                        document.getElementById("vs-join-button").disabled = "disabled";
                        joinGame(code, getAndSaveUsername("vs-username"));
                    };

                    metadataPeer.destroy();
                });
                metadataCon.send([ 255 ]);
            });
        });
    }

    // Tetris code
    function initGrid(id, width, height) {
        const element = document.getElementById(id);
        element.style.gridTemplateColumns = "repeat(" + width + ", 1fr)";
        element.style.gridAutoRows = (100 / height) + "%";
        element.innerHTML = "";
        return element;
    }

    function fetchLeaderboard(url) {
        document.getElementById("leaderboard").innerHTML = "Loading..";
        fetch(url)
            .then(r => r.json())
            .then(d => {
                let i = 1;
                let str = "<div class='leaderboard-left-h'>Rank</div><div class='leaderboard-left-h'>Username</div><div class='leaderboard-right-h'>Lines / Time</div>";
                d.forEach(e => {
                    str += "<div class='leaderboard-left'>#" + i
                        + "</div><div class='leaderboard-left'>" + e.username
                        + (url.endsWith("time")
                            ? "</div><div class='leaderboard-right'>" + formatTime(e.time) + "</div>"
                            : "</div><div class='leaderboard-right'>" + e.lines + " <span style='color: #999; font-size: 12px;'>" + formatTime(e.time) + "</span></div>");
                    i++;
                });
                document.getElementById("leaderboard").innerHTML = str;
            });
    }

    function start() {
        Tone.start();
        document.addEventListener("keydown", handleKeyDown);
        TOASTS.forEach(t => t.style.display = "none");

        lastTime = performance.now();
        timer = 0;
        clearedLines = 0;
        buh = 0;
        tempBuh = 0;
        updateLinesCleared();
        boards.forEach(b => b.fill(0));
        fallingBoards.forEach(b => b.fill(0));

        // Generate random next pieces
        for (let i = 0; i < 5; i++) {
            nextPieces[i] = PIECES[7 * Math.random() | 0];
        }
        holdingPiece = undefined;
        initGrid("holding", 1, 1);
        document.getElementById("holding").innerHTML =`<div class="grid-cell"></div>`;

        summonPiece();
        render();

        tickId = setInterval(tickInterval, 10);
        gameId = (Math.random() + 1).toString(36).substring(7);
        moves = "";
        fetch("https://api.bleach.dev/tetris/startgame?id=" + gameId);
    }

    function stop() {
        document.removeEventListener("keydown", handleKeyDown);
        openToast(serverCon ? "vs-join-toast" : "play-toast");

        clearInterval(tickId);
    }

    function resume() {
        document.addEventListener("keydown", handleKeyDown);
        closeToast("play-toast");

        lastTime = performance.now();
        tickId = setInterval(tickInterval, 10);
    }

    function tick() {
        if (!offsetFalling(0, 1, 0)) {
            if (gracePeriod > 0) {
                gracePeriod = -1;
                return;
            }

            for (let j = 0; j < fallingBoards[0].length; j++) {
                if (fallingBoards[0][j]) {
                    boards[0][j] = fallingBoards[0][j];
                    moves += "c" + j;
                }
            }
            fallingBoards[0].fill(0);

            // Clear lines
            let linesClearedHere = 0;
            for (let line = 0; line < boards[0].length; line += width) {
                if (boards[0].slice(line, line + width).every(v => v)) {
                    for (let cell = line + width - 1; cell >= 0; cell--) {
                        boards[0][cell] = cell < width ? 0 : boards[0][cell - width];
                    }

                    clearedLines++;
                    linesClearedHere++;
                    if (serverCon) {
                        serverCon.send([ 1, 3 + ~~(Math.random() * 13) ]);
                    } else {
                        buh++;
                    }

                    if (clearedLines === 40) {
                        if (!serverCon) {
                            document.getElementById("play-text").innerHTML = `<span style="color: #9cff8d;">You cleared 40 lines in ${document.getElementById("timer").innerText}!</span>`;
                            document.getElementById("play-button").innerText = "Continue";
                            document.getElementById("play-button").onclick = resume;

                            stop();
                            fetch(`https://api.bleach.dev/tetris/submittime?id=${gameId}&name=${getAndSaveUsername("username")}&lines=${clearedLines}&time=${timer}&version=v1.2.1`, {
                                method: 'POST',
                                body: moves
                            }).then(r => r.ok);
                        }
                    }

                    updateLinesCleared();
                }
            }

            summonPiece(linesClearedHere);
            canHold = true;
        } else {
            gracePeriod = 0;
        }

        if (serverCon) {
            serverCon.send([0, boards[0], fallingBoards[0] ].concat(nextPieces.slice(0, 5)));
        }

        render();
    }

    function updateLinesCleared() {
        document.getElementById("cleared-text").innerText = "Lines Cleared: " + clearedLines;
        document.getElementById("progressbar").style.width = (clearedLines / 40 * 100) + "%";
    }

    function render() {
        for (let b = 0; b < boards.length; b++) {
            // Reset board
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    document.getElementById((b ? "vs-" : "") + "tetris-" + x + "-" + y).style.border = null;
                }
            }

            // Ghost rendering
            for (let i = 1; i <= height; i++) {
                if (!offsetFalling(0, i, b, false)) {
                    for (let x = 0; x < width; x++) {
                        for (let y = 0; y < height; y++) {
                            if (getBoard(fallingBoards[b], x, y)) {
                                document.getElementById((b ? "vs-" : "") + "tetris-" + x + "-" + (y + i - 1)).style.border = "2px solid " + getBoard(fallingBoards[b], x, y);
                            }
                        }
                    }
                    break;
                }
            }

            // Board rendering
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (getBoard(fallingBoards[b], x, y))
                        document.getElementById((b ? "vs-" : "") + "tetris-" + x + "-" + y).style.border = "12px solid " + getBoard(fallingBoards[b], x, y);

                    if (getBoard(boards[b], x, y))
                        document.getElementById((b ? "vs-" : "") + "tetris-" + x + "-" + y).style.border = "12px solid " + getBoard(boards[b], x, y);
                }
            }
        }
    }

    function offsetFalling(offsetX, offsetY, index, write = true) {
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                if (getBoard(fallingBoards[index], x, y) && getBoard(boards[index], x + offsetX, y + offsetY)) {
                    return false;
                }
            }
        }

        if (write) {
            const buffer = fallingBoards[index].slice();
            fallingBoards[index].fill(0);
            for (let i = 0; i < fallingBoards[index].length; i++) {
                if (buffer[i]) {
                    fallingBoards[index][i + offsetY * width + offsetX] = buffer[i];
                }
            }
        }
        return true;
    }

    function cropBoard(brd) {
        let minX, minY, maxX, maxY;
        for (let i = 0; i < brd.length; i++) {
            if (brd[i]) {
                maxY = Math.floor(i / width);
                if (minY === undefined) {
                    minY = maxY;
                }
            }
        }

        for (let i = 0; i < brd.length + width - 1; i += width) {
            if (i >= width * height) {
                i = i % (width * height) + 1;
            }

            if (brd[i]) {
                maxX = Math.floor(i % width);
                if (minX === undefined) {
                    minX = maxX;
                }
            }
        }

        const piece = new Piece(new Array((maxX - minX + 1) * (maxY - minY + 1)), (maxX - minX) + 1);
        for (let y = 0; y <= maxY - minY; y++) {
            for (let x = 0; x <= maxX - minX; x++) {
                piece.array[y * piece.width + x] = brd[(minY + y) * width + minX + x];
            }
        }

        const centerX = Math.round((minX + maxX) / 2);
        const centerY = Math.round((minY + maxY) / 2);
        return {
            "piece": piece,
            "minX": minX,
            "minY": minY,
            "maxX": maxX,
            "maxY": maxY,
            "centerX": centerX,
            "centerY": centerY
        };
    }

    function rotateFalling(reverse) {
        const c = cropBoard(fallingBoards[0]);
        const newX = c.centerX - (c.centerY - c.minY);
        const newY = c.centerY - (c.centerX - c.minX);

        for (let o of reverse ? [[0, 0], [1, 0], [1, -1], [0, -2], [1, 2], [-1, 0], [-2, 0]] : [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2], [1, 0], [2, 0]]) {
            let found = true;
            for (let x = 0; x <= c.maxX - c.minX; x++) {
                for (let y = 0; y <= c.maxY - c.minY; y++) {
                    if (getBoard(fallingBoards[0], c.minX + x, c.minY + y) && getBoard(boards[0], newX + (c.maxY - c.minY) - y + o[0], newY + x + o[1])) {
                        found = false;
                    }
                }
            }

            if (found) {
                const buffer = fallingBoards[0].slice();
                fallingBoards[0].fill(0);
                for (let x = 0; x <= c.maxX - c.minX; x++) {
                    for (let y = 0; y <= c.maxY - c.minY; y++) {
                        if (buffer[(c.minY + y) * width + c.minX + x]) {
                            fallingBoards[0][(newY + (reverse ? (c.maxX - c.minX) - x : x) + o[1]) * width + newX + (reverse ? y : (c.maxY - c.minY) - y) + o[0]] = buffer[(c.minY + y) * width + c.minX + x];
                        }
                    }
                }

                render();
                return;
            }
        }
    }

    function holdPiece() {
        if (!canHold) {
            SYNTH.triggerAttackRelease("A2", "24n", Tone.now(), 0.2);
            return;
        }

        const c = cropBoard(fallingBoards[0]);

        putPieceInGrid("holding", c.piece)

        // Swap or summon new piece on the board
        fallingBoards[0].fill(0);
        if (holdingPiece !== undefined) {
            for (let i = 0; i < holdingPiece.array.length; i++) {
                fallingBoards[0][Math.floor(i / holdingPiece.width) * width + (i % holdingPiece.width) + 4] = holdingPiece.array[i];
            }
        } else {
            summonPiece();
        }

        holdingPiece = c.piece;
        canHold = false;
        SYNTH.triggerAttackRelease("C5", "24n", Tone.now(), 0.3);
        render();
    }

    function putPieceInGrid(elementName, piece) {
        let dimensions = Math.max(piece.width, piece.height);
        if (dimensions < 3)
            dimensions += 2;
        const offsetX = Math.floor((dimensions - piece.width) / 2);
        const offsetY = Math.floor((dimensions - piece.height) / 2);

        // Create holding grid
        const element = initGrid(elementName, dimensions, dimensions);
        for (let y = 0; y < dimensions; y++) {
            for (let x = 0; x < dimensions; x++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add('grid-cell');
                element.appendChild(cellElement);

                if ((x - offsetX) >= 0 && (x - offsetX) < piece.width && (y - offsetY) >= 0 && (y - offsetY) < piece.height) {
                    cellElement.style.border = (dimensions > 5 ? 5 : dimensions > 3 ? 8 : 10) + "px solid " + piece.array[(y - offsetY) * piece.width + (x - offsetX)];
                }
            }
        }
    }

    function updateNextPieces() {
        for (let i = 0; i < nextPieces.length; i++) {
            putPieceInGrid("next-" + (i + 1), nextPieces[i]);
        }
    }

    function summonPiece(counterLines = 0) {
        const nextPiece = nextPieces.shift();
        moves += "s" + PIECES.indexOf(nextPiece);
        for (let i = 0; i < nextPiece.array.length; i++) {
            const boardPos = 5 - Math.floor(nextPiece.width / 2) + Math.floor(i / nextPiece.width) * width + (i % nextPiece.width);
            if (boards[0][boardPos]) {
                if (serverCon) {
                    serverCon.send([ 254, "", yourIndex ]);
                    document.getElementById("vs-join-text").innerHTML = `<span style="color: #ff8d90;">You Lost after clearing ${clearedLines} line${clearedLines === 1 ? "" : "s"}.</span>`;
                    document.getElementById("vs-join-button").innerText = "Rematch";
                } else {
                    document.getElementById("play-text").innerHTML = `<span style="color: #ff8d90;">You Lost after clearing ${clearedLines} line${clearedLines === 1 ? "" : "s"}.</span>`;
                    document.getElementById("play-button").innerText = "Restart";
                    document.getElementById("play-button").onclick = start;

                    fetch(`https://api.bleach.dev/tetris/submitlines?id=${gameId}&name=${getAndSaveUsername("username")}&lines=${clearedLines}&time=${timer}&version=v1.2.1`, {
                        method: 'POST',
                        body: moves
                    }).then(r => r.ok);
                }

                stop();
                return;
            }

            fallingBoards[0][boardPos] = nextPiece.array[i];
        }

        tempBuh = tempBuh - counterLines * 15;
        if (tempBuh > 5) {
            let piece = ~~(Math.random() * Math.min(3 + tempBuh, BUH_PIECES.length));
            tempBuh = Math.max(tempBuh - piece - 2, 0);
            nextPieces.splice(4, 0, BUH_PIECES[piece]);
        } else {
            tempBuh = 0;
            nextPieces.splice(4, 0, PIECES[~~(Math.random() * Math.min(7 + buh, PIECES.length))]);
        }

        if (serverCon)
            document.getElementById("vs-player-1").innerText = `${vsPlayers[yourIndex]} (Buh: ${buh}+${tempBuh})`;
        updateNextPieces();
    }

    function getBoard(brd, x, y) {
        return (x < 0 || x >= width || y < 0 || y >= height) ? 99 : brd[y * width + x];
    }

    function openToast(id, closeOthers = true) {
        TOASTS.forEach(t => t.style.display = id === t.id ? "flex" : closeOthers ? "none" : t.style.display);
    }

    function closeToast(id) {
        TOASTS.find(t => id === t.id).style.display = "none";
    }

    // Misc code
    function getAndSaveUsername(id) {
        const name = document.getElementById(id).value;
        document.cookie = "username=" + name + "; max-age=2592000";
        return name;
    }

    function formatTime(ms) {
        const minutes = Math.floor(ms / 1000 / 60);
        const seconds = Math.floor(ms / 1000) % 60;
        const millis = Math.floor(ms / 10) % 100;
        return (minutes < 10 ? "0" : "") + minutes + ":" + (seconds < 10 ? "0" : "") + seconds + "." + (millis < 10 ? "0" : "") + millis;
    }

    // Multiplayer code
    function hostGame(username) {
        let roomCode = "";
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        for (let i = 0; i < 4; i++) {
            roomCode += characters.charAt(~~(Math.random() * characters.length));
        }

        document.getElementById("vs-code").innerText = "tetris.bleach.dev/?join=" + roomCode;
        document.getElementById("vs-copy").onclick = () => navigator.clipboard.writeText("https://tetris.bleach.dev/?join=" + roomCode);
        openToast("vs-toast");

        let clientAcceptor = new peerjs.Peer("bl-ttne-" + roomCode);
        clientAcceptor.on('open', id => {
            console.log('Server peer ID is: ' + id);

            clientAcceptor.on('connection', clientCon => {
                console.log("Client Accepted", clientCon);

                clientCon.on('data', data => {
                    if (data[0] !== 0)
                        console.log("Server Received", data);

                    let clIndex = clients.indexOf(clientCon);
                    if (data[0] === 0) {
                        for (const cl of clients) {
                            if (clients.indexOf(cl) !== clIndex) {
                                cl.send(data);
                            }
                        }
                    } else if (data[0] === 1) {
                        clients[clIndex ? 0 : 1].send(data);
                    } else if (data[0] === 253) {
                        if (!rematches.includes(clIndex)) {
                            rematches.push(clIndex)
                            for (const cl of clients) {
                                cl.send([252, `${rematches.map(i => vsPlayers[i]).join(", ")} Wants a rematch!`]);
                            }

                            if (rematches.includes(0) && rematches.includes(1)) {
                                startCountdown();
                            }
                        }
                    } else if (data[0] === 254) {
                        for (const cl of clients) {
                            if (clients.indexOf(cl) !== clIndex) {
                                cl.send(data);
                            }
                            cl.send([ 253 ]);
                        }
                    } else if (data[0] === 255) {
                        if (data.length >= 2 && clIndex === -1) {
                            console.log("Client Added To Game", clientCon);
                            clIndex = clients.push(clientCon) - 1;
                            vsPlayers.push(data[1]);

                            for (let i = 0; i < clients.length - 1; i++) {
                                clients[i].send([ 255, i ].concat(vsPlayers));
                            }

                            if (vsPlayers.length === 2) {
                                document.getElementById("vs-join-button").disabled = "disabled";
                                startCountdown();
                            }
                        }

                        clientCon.send([ 255, clIndex ].concat(vsPlayers));
                    }
                });
            });
        });
        console.log(clientAcceptor);

        joinGame(roomCode, username);
    }

    function startCountdown() {
        let countdown = 3;
        let countdownFunc = setInterval(() => {
            if (countdown > 0) {
                for (const cl of clients) {
                    cl.send([ 252, countdown + ".." ]);
                }
            } else {
                for (let i = 0; i < clients.length; i++) {
                    clients[i].send([ 252, "Click Rematch to rematch" ]);
                    clients[i].send([ 253, 1 ]);
                }
                clearInterval(countdownFunc);
            }
            countdown--;
        }, 700);
    }

    function joinGame(roomCode, username) {
        const toServerPeer = new peerjs.Peer();
        toServerPeer.on('open', id => {
            console.log('Client peer ID is: ' + id);

            serverCon = toServerPeer.connect("bl-ttne-" + roomCode);
            serverCon.on('open', () => {
                serverCon.on('data', data => {
                    if (data[0] !== 0)
                        console.log("Client Received", data);

                    if (data[0] === 0) {
                        boards[1] = data[1];
                        fallingBoards[1] = data[2];
                        for (let i = 0; i < 5; i++)
                            nextPieces[5 + i] = data[3 + i];

                        updateNextPieces();
                        render();
                    } else if (data[0] === 1) {
                        buh++;
                        tempBuh += data[1];
                        document.getElementById("vs-player-1").innerText = `${vsPlayers[yourIndex]} (Buh: ${buh}+${tempBuh})`;
                    } else if (data[0] === 252) {
                        document.getElementById("vs-join-text-2").innerHTML = data[1];
                        document.getElementById("vs-username-container").style.display = "none";
                        SYNTH.triggerAttackRelease("A4", "128n", Tone.now(), 0.3);
                        stop();
                    } else if (data[0] === 253) {
                        if (data.length >= 2) {
                            rematches = [];
                            start();
                        } else {
                            document.getElementById("vs-join-button").disabled = "";
                            document.getElementById("vs-join-button").onclick = () => {
                                serverCon.send([ 253 ]);
                                document.getElementById("vs-join-button").disabled = "disabled";
                            }
                        }
                    } else if (data[0] === 254) {
                        document.getElementById("vs-join-text").innerHTML = `<span style="color: #9cff8d;">You Won after clearing ${clearedLines} line${clearedLines === 1 ? "" : "s"}.</span>`;
                        document.getElementById("vs-join-button").innerText = "Rematch";
                        stop();
                    } else if (data[0] === 255) {
                        vsPlayers = data.slice(2);
                        yourIndex = data[1];

                        document.getElementById("vs-player-1").innerText = vsPlayers[yourIndex];
                        document.getElementById("vs-player-2").innerText = vsPlayers.length >= 2 ? vsPlayers[yourIndex === 1 ? 0 : 1] : "...";
                    }
                });

                console.log("Connected to server!");
                const path = window.location.protocol + "//" + window.location.host + window.location.pathname + "?join=" + roomCode;
                window.history.pushState({ path: path }, '', path);

                document.getElementById("vs-container").style.display = "inline-block";
                document.getElementById("vs-text-container").style.display = "block";
                document.getElementById("sp-text-container").style.display = "none";

                serverCon.send([ 255, username ]);
            });
        });
    }

    function clearVs() {
        rematches = [];
        vsPlayers = [];
        yourIndex = -1;
        clients = [];
        serverCon?.close();
        serverCon = undefined;
        document.getElementById("vs-container").style.display = "none";
        document.getElementById("vs-text-container").style.display = "none";
        document.getElementById("sp-text-container").style.display = "block";
    }
</script>
</body>
</html>